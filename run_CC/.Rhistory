rm(list=ls())
library(brms)   # for model fitting
source('fx.R')  # for simulation
setwd("~/Documents/bayesMLMFit/run_CC/r_scripts")
setwd('..')
library(brms)   # for model fitting
source('fx.R')  # for simulation
# convenience function for diagnostics summary
diag_p = function(x) bayestestR::diagnostic_posterior(x, effects='all')
options(mc.cores=2) # 2 chains per model
# Specify constants (to be replaced) --------------------------------------
COND  = 77
CONST = c(50,50,1,0.04,0.2,0.04,0.4,0,0,0,0.1,0,0,0,0,0,1,1,1,100,2,3000,1000,1,0.72)
names(CONST) = c("N", "J", "G00", "TAU0", "G10", "TAU1", "G20", "TAU2",
"G30", "TAU3", "RHO01", "RHO02", "RHO12", "X1_mu",
"X2_mu", "X3_mu", "X1_sd", "X2_sd", "X3_sd", "S",
"nchain","niter","burn","thin", "SIG2")
CONST = as.data.frame(t(CONST))
CONST
DM    = expand.grid(1:10,1:10) # design matrix (dummy N & J)
DM$X1 = rnorm(nrow(DM)) # mean and sd don't matter here, just setting up model structure
DM$X2 = rnorm(nrow(DM))
DM$X3 = rnorm(nrow(DM))
DM$y  = rnorm(nrow(DM)) # same for the outcome
colnames(DM) = c('obs','g','X1','X2','X3', 'y')
options(mc.cores=CONST$nchain)
rm(list=ls())
library(brms)   # for model fitting
source('fx.R')  # for simulation
# convenience function for diagnostics summary
diag_p = function(x) bayestestR::diagnostic_posterior(x, effects='all')
options(mc.cores=2) # 2 chains per model
# Specify constants (to be replaced) --------------------------------------
COND  = 77
CONST = c(50,50,1,0.04,0.2,0.04,0.4,0,0,0,0.1,0,0,0,0,0,1,1,1,100,2,3000,1000,1,0.72)
names(CONST) = c("N", "J", "G00", "TAU0", "G10", "TAU1", "G20", "TAU2",
"G30", "TAU3", "RHO01", "RHO02", "RHO12", "X1_mu",
"X2_mu", "X3_mu", "X1_sd", "X2_sd", "X3_sd", "S",
"nchain","niter","burn","thin", "SIG2")
CONST = as.data.frame(t(CONST))
# Compile models ----------------------------------------------------
# Fit initial model to dummy data, then just call update below to avoid recompiling time.
# This is OS-specific, so has to be run once on the cluster before each simulation cell.
# Fit five models:
# A. True model
# B. The (incorrect) absence of a random effect (TAU1 = 0)
# C. The (incorrect) presence of a random effect (TAU2 > 0)
# D. The (incorrect) absence of a fixed effect (G20 = 0)
# E. The (incorrect) presence of a fixed effect (G30 != 0)
DM    = expand.grid(1:10,1:10) # design matrix (dummy N & J)
DM$X1 = rnorm(nrow(DM)) # mean and sd don't matter here, just setting up model structure
DM$X2 = rnorm(nrow(DM))
DM$X3 = rnorm(nrow(DM))
DM$y  = rnorm(nrow(DM)) # same for the outcome
colnames(DM) = c('obs','g','X1','X2','X3', 'y')
options(mc.cores=CONST$nchain)
modA = brm(y ~ 1 + X1 + X2 + (X1|g),      data=DM, chains=CONST$nchain, iter=CONST$niter, warmup=CONST$burn, thin=CONST$thin, silent = 2)
modB = brm(y ~ 1 + X1 + X2 + (1|g),       data=DM, chains=CONST$nchain, iter=CONST$niter, warmup=CONST$burn, thin=CONST$thin, silent = 2)
modC = brm(y ~ 1 + X1 + X2 + (X1+X2|g),   data=DM, chains=CONST$nchain, iter=CONST$niter, warmup=CONST$burn, thin=CONST$thin, silent = 2)
modD = brm(y ~ 1 + X1 + (X1|g),           data=DM, chains=CONST$nchain, iter=CONST$niter, warmup=CONST$burn, thin=CONST$thin, silent = 2)
modE = brm(y ~ 1 + X1 + X2 + X3 + (X1|g), data=DM, chains=CONST$nchain, iter=CONST$niter, warmup=CONST$burn, thin=CONST$thin, silent = 2)
# Generate dataset --------------------------------------------------------
# Simulate from true model
g  = rep(1:CONST$N, each=CONST$J)
X1 = rnorm(n=CONST$N*CONST$J, mean=CONST$X1_mu, sd=CONST$X1_sd)
X2 = rnorm(n=CONST$N*CONST$J, mean=CONST$X2_mu, sd=CONST$X2_sd)
X3 = rnorm(n=CONST$N*CONST$J, mean=CONST$X3_mu, sd=CONST$X3_sd)
dm = data.frame(X1=X1,X2=X2,X3=X3,g=g)
# Store pars in list
pars = list(GAMMA=c(CONST$G00, CONST$G10, CONST$G20),
TAU=matrix(c(CONST$TAU0,
CONST$RHO01*sqrt(CONST$TAU0)*sqrt(CONST$TAU1),
CONST$RHO01*sqrt(CONST$TAU0)*sqrt(CONST$TAU1),
CONST$TAU1), 2, 2),
SIGMA=CONST$SIG)
names(pars$GAMMA) = c('(Intercept)','X1','X2')
# simulate from true model S times
y = simulate_lmer(y ~ X1 + X2 + (X1|g), DM=dm, pars=pars, nsim = CONST$S)
# Fit each model to each dataset and compute fit indices --------------------------------------------------
out   = list() # output to save
View(dm)
View(DM)
table(DM$g)
CONST
dat = dm
dat$y = y[,s]
s=1
dat$y = y[,s]
View(dat)
table(dat$g)
write.csv(dat, "~/Desktop/example_dataset_77.csv")
x77 = readRDS('../analysis/data/raw_data/cond_77.rds')
x77
x77[[1]]$data
xx = x77[[1]]$data
View(xx)
xx = x77[[1]]$ranef$A$g
x77[[1]]$ranef$A$g
