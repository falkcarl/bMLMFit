setwd("~/Documents/bayesMLMFit/analysis")
x = readRDS('data/raw_data/cond_1.rds')
x[[1]]$dic
unlist(x[[1]]$dic)
i = 1
sapply(x[[i]]$dic, function(x) x["DIC")]
sapply(x[[i]]$dic, function(x) x["DIC"))
sapply(x[[i]]$dic, function(x) x["DIC"]))
sapply(x[[i]]$dic, function(x) x["DIC"]))
sapply(x[[i]]$dic, function(x) x["DIC"])
dics = sapply(x[[i]]$dic, function(x) x["DIC"])
names(dics) = LETTERS[1:5]
which.min(dics)
correct = 0
for(i in 1:10) {
dics = sapply(x[[i]]$dic, function(x) x["DIC"])
names(dics) = LETTERS[1:5]
selected_mod = names(which.min(dics))
if(selected_mod=='A') correct = correct+1
}
correct
mean(correct)
correct / 10
correct = 0
for(i in 1:10) {
dics = sapply(x[[i]]$dic, function(x) x["DIC"])
names(dics) = LETTERS[1:5]
selected_mod = names(which.min(dics))
print(selected_mod)
if(selected_mod=='A') correct = correct+1
}
chosen = list(A=0,B=0,C=0,D=0,E=0)
for(i in 1:10) {
dics = sapply(x[[i]]$dic, function(x) x["DIC"])
names(dics) = LETTERS[1:5]
selected_mod = names(which.min(dics))
chosen[[selected_mod]] = chosen[[selected_mod]]+1
}
chosen
chosen = c(A=0,B=0,C=0,D=0,E=0)
for(i in 1:10) {
dics = sapply(x[[i]]$dic, function(x) x["DIC"])
names(dics) = LETTERS[1:5]
selected_mod = names(which.min(dics))
chosen[selected_mod] = chosen[selected_mod]+1
}
chosen
x[[i]]$waic
x[[i]]$waic
## DIC
dics = sapply(x[[i]]$waic, function(x) x['waic',"Estimate"])
## DIC
est = sapply(x[[i]]$waic, function(x) x['waic',"Estimate"])
est
x[[i]]$waic
## DIC
est = sapply(x[[i]]$waic, function(x) x['waic',"Estimate"])
names(est) = LETTERS[1:5]
names(which.min(est))
selected_mod = names(which.min(est))
## WAIC
est = sapply(x[[i]]$loo, function(x) x['loo',"Estimate"])
x[[i]]$loo,
x[[i]]$loo
## WAIC
est = sapply(x[[i]]$loo, function(x) x['looic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
rm(list=ls())
x = readRDS('data/raw_data/cond_1.rds')
chosen_DIC  = c(A=0,B=0,C=0,D=0,E=0)
chosen_WAIC = c(A=0,B=0,C=0,D=0,E=0)
chosen_LOO  = c(A=0,B=0,C=0,D=0,E=0)
for(i in 1:10) {
## DIC
est = sapply(x[[i]]$dic, function(x) x["DIC"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_DIC[selected_mod] = chosen_DIC[selected_mod]+1
## WAIC
est = sapply(x[[i]]$waic, function(x) x['waic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_waic[selected_mod] = chosen_waic[selected_mod]+1
## WAIC
est = sapply(x[[i]]$loo, function(x) x['looic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_loo[selected_mod] = chosen_loo[selected_mod]+1
}
rm(list=ls())
x = readRDS('data/raw_data/cond_1.rds')
chosen_DIC  = c(A=0,B=0,C=0,D=0,E=0)
chosen_WAIC = c(A=0,B=0,C=0,D=0,E=0)
chosen_LOO  = c(A=0,B=0,C=0,D=0,E=0)
for(i in 1:10) {
## DIC
est = sapply(x[[i]]$dic, function(x) x["DIC"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_DIC[selected_mod] = chosen_DIC[selected_mod]+1
## WAIC
est = sapply(x[[i]]$waic, function(x) x['waic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_WAIC[selected_mod] = chosen_WAIC[selected_mod]+1
## WAIC
est = sapply(x[[i]]$loo, function(x) x['looic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_LOO[selected_mod] = chosen_LOO[selected_mod]+1
}
chosen
chosen_dic
chosen_DIC
chosen_WAIC
chosen_LOO
chosen_DIC/n
chosen_WAIC/n
rm(list=ls())
x = readRDS('data/raw_data/cond_1.rds')
chosen_DIC  = c(A=0,B=0,C=0,D=0,E=0)
chosen_WAIC = c(A=0,B=0,C=0,D=0,E=0)
chosen_LOO  = c(A=0,B=0,C=0,D=0,E=0)
n = 10
for(i in 1:n) {
## DIC
est = sapply(x[[i]]$dic, function(x) x["DIC"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_DIC[selected_mod] = chosen_DIC[selected_mod]+1
## WAIC
est = sapply(x[[i]]$waic, function(x) x['waic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_WAIC[selected_mod] = chosen_WAIC[selected_mod]+1
## WAIC
est = sapply(x[[i]]$loo, function(x) x['looic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_LOO[selected_mod] = chosen_LOO[selected_mod]+1
}
chosen_DIC/n
chosen_WAIC/n
chosen_LOO/n
x = read.csv('~/Downloads/minisim.txt', sep = '\t')
View(x)
x = read.csv('~/Downloads/minisim.txt', sep = ',')
x = read.csv('~/Downloads/minisim.txt')
View(x)
x = read.csv('~/Downloads/minisim.txt', sep=' ')
View(x)
rm(list=ls())
x = readRDS('data/raw_data/cond_1.rds')
chosen_DIC  = c(A=0,B=0,C=0,D=0,E=0)
chosen_WAIC = c(A=0,B=0,C=0,D=0,E=0)
chosen_LOO  = c(A=0,B=0,C=0,D=0,E=0)
n = 10
for(i in 1:n) {
## DIC
est = sapply(x[[i]]$dic, function(x) x["DIC"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_DIC[selected_mod] = chosen_DIC[selected_mod]+1
## WAIC
est = sapply(x[[i]]$waic, function(x) x['waic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_WAIC[selected_mod] = chosen_WAIC[selected_mod]+1
## WAIC
est = sapply(x[[i]]$loo, function(x) x['looic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_LOO[selected_mod] = chosen_LOO[selected_mod]+1
}
chosen_DIC/n
chosen_WAIC/n
chosen_LOO/n
x = read.csv('~/Downloads/minisim.txt')
View(x)
x = read.csv('~/Downloads/minisim.txt', sep=' ')
View(x)
library(dplyr)
x %>%
group_by(rep, model)
x %>%
group_by(rep, model) %>%
model[cond.DIC==min(cond.DIC))
unique(x$est)
library(dplyr)
x = read.csv('~/Downloads/minisim.txt', sep=' ')
for(r in 1:10) {
for(e in unique(x$est)) {
xx = x[x$rep==r & x$est==e, ]
}
}
xx
which.min(xx$cond.DIC)
library(dplyr)
x = read.csv('~/Downloads/minisim.txt', sep=' ')
blimp_acc = 0
brms_acc  = 0
for(r in 1:10) {
for(e in c('brms')) {
xx = x[x$rep==r & x$est==e, ]
if(which.min(xx$cond.DIC)==1) brms_acc=brms_acc+1
}
}
brms_acc
r
r=1
xx = x[x$rep==r & x$est==e, ]
xx
rm(list=ls())
x = readRDS('data/raw_data/cond_1.rds')
chosen_DIC  = c(A=0,B=0,C=0,D=0,E=0)
chosen_WAIC = c(A=0,B=0,C=0,D=0,E=0)
chosen_LOO  = c(A=0,B=0,C=0,D=0,E=0)
n = 10
for(i in 1:n) {
## DIC
est = sapply(x[[i]]$dic, function(x) x["DIC"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_DIC[selected_mod] = chosen_DIC[selected_mod]+1
## WAIC
est = sapply(x[[i]]$waic, function(x) x['waic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_WAIC[selected_mod] = chosen_WAIC[selected_mod]+1
## WAIC
est = sapply(x[[i]]$loo, function(x) x['looic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_LOO[selected_mod] = chosen_LOO[selected_mod]+1
}
chosen_DIC/n
chosen_WAIC/n
chosen_LOO/n
rm(list=ls())
x = readRDS('data/raw_data/cond_1.rds')
chosen_DIC  = c(A=0,B=0,C=0,D=0,E=0)
chosen_WAIC = c(A=0,B=0,C=0,D=0,E=0)
chosen_LOO  = c(A=0,B=0,C=0,D=0,E=0)
n = 10
for(i in 1:n) {
## DIC
est = sapply(x[[i]]$dic, function(x) x["DIC"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_DIC[selected_mod] = chosen_DIC[selected_mod]+1
## WAIC
est = sapply(x[[i]]$waic, function(x) x['waic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_WAIC[selected_mod] = chosen_WAIC[selected_mod]+1
## WAIC
est = sapply(x[[i]]$loo, function(x) x['looic',"Estimate"])
names(est) = LETTERS[1:5]
selected_mod = names(which.min(est))
chosen_LOO[selected_mod] = chosen_LOO[selected_mod]+1
}
chosen_DIC/n
chosen_WAIC/n
chosen_LOO/n
sapply(x[[i]]$dic, function(x) x["DIC"])
sapply(x[[i]]$dic, function(x) x["DIC"])
setwd("~/Documents/bayesMLMFit/run_CC/study1/r_scripts")
setwd('../..')
rm(list=ls())
source('fx.R')  # for simulation
setwd('study1/')
# convenience function for diagnostics summary
diag_p = function(x) bayestestR::diagnostic_posterior(x, effects='all')
options(mc.cores=2) # 2 chains per model
source('fx.R')  # for simulation
# convenience function for diagnostics summary
diag_p = function(x) bayestestR::diagnostic_posterior(x, effects='all')
options(mc.cores=2) # 2 chains per model
# Specify constants (to be replaced) --------------------------------------
COND  = 1
CONST = c(20,10,1,0.04,0.2,0.04,0.2,0,0,0,0.1,0,0,0,0,0,1,1,1,100,2,3000,1000,1,0,0.84)
names(CONST) = c("N", "J", "G00", "TAU0", "G10", "TAU1", "G20", "TAU2",
"G30", "TAU3", "RHO01", "RHO02", "RHO12", "X1_mu",
"X2_mu", "X3_mu", "X1_sd", "X2_sd", "X3_sd", "S",
"nchain","niter","burn","thin","marg","SIG2")
CONST = as.data.frame(t(CONST))
rm(list=ls())
source('fx.R')  # for simulation
# convenience function for diagnostics summary
diag_p = function(x) bayestestR::diagnostic_posterior(x, effects='all')
options(mc.cores=2) # 2 chains per model
# Specify constants (to be replaced) --------------------------------------
COND  = 1
CONST = c(20,10,1,0.04,0.2,0.04,0.2,0,0,0,0.1,0,0,0,0,0,1,1,1,100,2,3000,1000,1,0,0.84)
names(CONST) = c("N", "J", "G00", "TAU0", "G10", "TAU1", "G20", "TAU2",
"G30", "TAU3", "RHO01", "RHO02", "RHO12", "X1_mu",
"X2_mu", "X3_mu", "X1_sd", "X2_sd", "X3_sd", "S",
"nchain","niter","burn","thin","marg","SIG2")
CONST = as.data.frame(t(CONST))
# Simulate from true model
g  = rep(1:CONST$N, each=CONST$J)
X1 = rnorm(n=CONST$N*CONST$J, mean=CONST$X1_mu, sd=CONST$X1_sd)
X2 = rnorm(n=CONST$N*CONST$J, mean=CONST$X2_mu, sd=CONST$X2_sd)
X3 = rnorm(n=CONST$N*CONST$J, mean=CONST$X3_mu, sd=CONST$X3_sd)
dm = data.frame(X1=X1,X2=X2,X3=X3,g=g)
# Store pars in list
pars = list(GAMMA=c(CONST$G00, CONST$G10, CONST$G20),
TAU=matrix(c(CONST$TAU0,
CONST$RHO01*sqrt(CONST$TAU0)*sqrt(CONST$TAU1),
CONST$RHO01*sqrt(CONST$TAU0)*sqrt(CONST$TAU1),
CONST$TAU1), 2, 2),
SIGMA=CONST$SIG)
names(pars$GAMMA) = c('(Intercept)','X1','X2')
y = simulate_lmer(y ~ X1 + X2 + (X1|g), DM=dm, pars=pars, nsim = CONST$S)
dat = dm
dat$y = y[,s]
s
i
rm(list=ls())
source('fx.R')  # for simulation
# convenience function for diagnostics summary
diag_p = function(x) bayestestR::diagnostic_posterior(x, effects='all')
options(mc.cores=2) # 2 chains per model
# Specify constants (to be replaced) --------------------------------------
COND  = 1
CONST = c(20,10,1,0.04,0.2,0.04,0.2,0,0,0,0.1,0,0,0,0,0,1,1,1,100,2,3000,1000,1,0,0.84)
names(CONST) = c("N", "J", "G00", "TAU0", "G10", "TAU1", "G20", "TAU2",
"G30", "TAU3", "RHO01", "RHO02", "RHO12", "X1_mu",
"X2_mu", "X3_mu", "X1_sd", "X2_sd", "X3_sd", "S",
"nchain","niter","burn","thin","marg","SIG2")
CONST = as.data.frame(t(CONST))
# Simulate from true model
g  = rep(1:CONST$N, each=CONST$J)
X1 = rnorm(n=CONST$N*CONST$J, mean=CONST$X1_mu, sd=CONST$X1_sd)
X2 = rnorm(n=CONST$N*CONST$J, mean=CONST$X2_mu, sd=CONST$X2_sd)
X3 = rnorm(n=CONST$N*CONST$J, mean=CONST$X3_mu, sd=CONST$X3_sd)
dm = data.frame(X1=X1,X2=X2,X3=X3,g=g)
# Store pars in list
pars = list(GAMMA=c(CONST$G00, CONST$G10, CONST$G20),
TAU=matrix(c(CONST$TAU0,
CONST$RHO01*sqrt(CONST$TAU0)*sqrt(CONST$TAU1),
CONST$RHO01*sqrt(CONST$TAU0)*sqrt(CONST$TAU1),
CONST$TAU1), 2, 2),
SIGMA=CONST$SIG)
names(pars$GAMMA) = c('(Intercept)','X1','X2')
y = simulate_lmer(y ~ X1 + X2 + (X1|g), DM=dm, pars=pars, nsim = CONST$S)
dat$y = y[,s]
dat = dm
dat$y = y[,s]
rm(list=ls())
source('fx.R')  # for simulation
# convenience function for diagnostics summary
diag_p = function(x) bayestestR::diagnostic_posterior(x, effects='all')
options(mc.cores=2) # 2 chains per model
# Specify constants (to be replaced) --------------------------------------
COND  = 1
CONST = c(20,10,1,0.04,0.2,0.04,0.2,0,0,0,0.1,0,0,0,0,0,1,1,1,100,2,3000,1000,1,0,0.84)
names(CONST) = c("N", "J", "G00", "TAU0", "G10", "TAU1", "G20", "TAU2",
"G30", "TAU3", "RHO01", "RHO02", "RHO12", "X1_mu",
"X2_mu", "X3_mu", "X1_sd", "X2_sd", "X3_sd", "S",
"nchain","niter","burn","thin","marg","SIG2")
CONST = as.data.frame(t(CONST))
# Simulate from true model
g  = rep(1:CONST$N, each=CONST$J)
X1 = rnorm(n=CONST$N*CONST$J, mean=CONST$X1_mu, sd=CONST$X1_sd)
X2 = rnorm(n=CONST$N*CONST$J, mean=CONST$X2_mu, sd=CONST$X2_sd)
X3 = rnorm(n=CONST$N*CONST$J, mean=CONST$X3_mu, sd=CONST$X3_sd)
dm = data.frame(X1=X1,X2=X2,X3=X3,g=g)
# Store pars in list
pars = list(GAMMA=c(CONST$G00, CONST$G10, CONST$G20),
TAU=matrix(c(CONST$TAU0,
CONST$RHO01*sqrt(CONST$TAU0)*sqrt(CONST$TAU1),
CONST$RHO01*sqrt(CONST$TAU0)*sqrt(CONST$TAU1),
CONST$TAU1), 2, 2),
SIGMA=CONST$SIG)
names(pars$GAMMA) = c('(Intercept)','X1','X2')
y = simulate_lmer(y ~ X1 + X2 + (X1|g), DM=dm, pars=pars, nsim = CONST$S)
for(s in 1:10) {
dat = dm
dat$y = y[,s]
}
dat
s=2
dat = dm
dat$y = y[,s]
dat
rm(list=ls())
source('fx.R')  # for simulation
# convenience function for diagnostics summary
diag_p = function(x) bayestestR::diagnostic_posterior(x, effects='all')
options(mc.cores=2) # 2 chains per model
# Specify constants (to be replaced) --------------------------------------
COND  = 1
CONST = c(20,10,1,0.04,0.2,0.04,0.2,0,0,0,0.1,0,0,0,0,0,1,1,1,100,2,3000,1000,1,0,0.84)
names(CONST) = c("N", "J", "G00", "TAU0", "G10", "TAU1", "G20", "TAU2",
"G30", "TAU3", "RHO01", "RHO02", "RHO12", "X1_mu",
"X2_mu", "X3_mu", "X1_sd", "X2_sd", "X3_sd", "S",
"nchain","niter","burn","thin","marg","SIG2")
CONST = as.data.frame(t(CONST))
# Simulate from true model
g  = rep(1:CONST$N, each=CONST$J)
X1 = rnorm(n=CONST$N*CONST$J, mean=CONST$X1_mu, sd=CONST$X1_sd)
X2 = rnorm(n=CONST$N*CONST$J, mean=CONST$X2_mu, sd=CONST$X2_sd)
X3 = rnorm(n=CONST$N*CONST$J, mean=CONST$X3_mu, sd=CONST$X3_sd)
dm = data.frame(X1=X1,X2=X2,X3=X3,g=g)
# Store pars in list
pars = list(GAMMA=c(CONST$G00, CONST$G10, CONST$G20),
TAU=matrix(c(CONST$TAU0,
CONST$RHO01*sqrt(CONST$TAU0)*sqrt(CONST$TAU1),
CONST$RHO01*sqrt(CONST$TAU0)*sqrt(CONST$TAU1),
CONST$TAU1), 2, 2),
SIGMA=CONST$SIG)
names(pars$GAMMA) = c('(Intercept)','X1','X2')
y = simulate_lmer(y ~ X1 + X2 + (X1|g), DM=dm, pars=pars, nsim = CONST$S)
for(s in 1:10) {
dat = dm
dat$y = y[,s]
write.csv(dat, paste0("~/Desktop/smallnj_",s,".csv"))
}
